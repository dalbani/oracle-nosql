<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Working with complex data</title>
    <link rel="stylesheet" href="gettingStarted.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.73.2" />
    <link rel="start" href="index.html" title="Getting Started with SQL for Oracle NoSQL Database" />
    <link rel="up" href="sfw_expression.html" title="Chapter 2. SQL for Oracle NoSQL Database Queries" />
    <link rel="prev" href="simple_expressions.html" title="Simple Select-From-Where Queries" />
    <link rel="next" href="functions.html" title="Built-in Functions" />
  </head>
  <body>
    <div xmlns="" class="navheader">
      <div class="libver">
        <p>Library Version 12.1.4.0</p>
      </div>
      <table width="100%" summary="Navigation header">
        <tr>
          <th colspan="3" align="center">Working with complex data</th>
        </tr>
        <tr>
          <td width="20%" align="left"><a accesskey="p" href="simple_expressions.html">Prev</a> </td>
          <th width="60%" align="center">Chapter 2. SQL for Oracle NoSQL Database Queries</th>
          <td width="20%" align="right"> <a accesskey="n" href="functions.html">Next</a></td>
        </tr>
      </table>
      <hr />
    </div>
    <div class="sect1" lang="en" xml:lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="complextypes"></a>Working with complex data</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <dl>
          <dt>
            <span class="sect2">
              <a href="complextypes.html#records">Working With Records</a>
            </span>
          </dt>
          <dt>
            <span class="sect2">
              <a href="complextypes.html#arrays">Working With Arrays</a>
            </span>
          </dt>
          <dt>
            <span class="sect2">
              <a href="complextypes.html#maps">Working With Maps</a>
            </span>
          </dt>
        </dl>
      </div>
      <p> 
            In this section we walk you through query examples that
            use complex types (arrays, maps, records). If you want to follow
            along the examples, you can run the
                <code class="literal">SQLAdvancedExamples</code> script found in the
            Examples folder, which creates the table and imports the data used. 
        </p>
      <p>
            The <code class="literal">SQLAdvancedExamples</code> script creates the
            following table: 
        </p>
      <pre class="programlisting">create table Persons (
  id integer,
  firstname string,
  lastname string,
  age integer,
  income integer,
  address record(street string,
                 city string,
                 state string,
                 phones array(record(type enum(work, home),
                                     areacode integer,
                                     number integer
                                   )
                            )
                ),
  connections array(integer),
  expenses map(integer),
  primary key (id)
); </pre>
      <p> 
            The script also imports the following table rows: 
        </p>
      <pre class="programlisting">{"id":1,
  "firstname":"David",
  "lastname":"Morrison",
  "age":25,
  "income":100000,
  "address":{"street":"150 Route 2",
             "city":"Antioch",
             "state":"TN",
             "phones":[{"type":"home", "areacode":423, "number":8634379}]
            },
  "connections":[2, 3],
  "expenses":{"food":1000, "gas":180}
};

{
  "id":2,
  "firstname":"John",
  "lastname":"Anderson",
  "age":35,
  "income":100000,
  "address":{"street":"187 Hill Street",
             "city":"Beloit",
             "state":"WI",
             "phones":[{"type":"home", "areacode":339, "number":1684972}]
            },
  "connections":[1, 3],
  "expenses":{"books":100, "food":1700, "travel":2100}
};

{
  "id":3,
  "firstname":"John",
  "lastname":"Morgan",
  "age":38,
  "income":100000000,
  "address":{"street":"187 Aspen Drive",
             "city":"Middleburg",
             "state":"FL",
             "phones":[{"type":"work", "areacode":305, "number":1234079},
                       {"type":"home", "areacode":305, "number":2066401}
                      ]
            },
  "connections":[1, 4, 2],
  "expenses":{"food":2000, "travel":700, "gas":10}
};

{
  "id":4,
  "firstname":"Peter",
  "lastname":"Smith",
  "age":38,
  "income":80000,
  "address":{"street":"364 Mulberry Street",
             "city":"Leominster",
             "state":"MA",
             "phones":[{"type":"work", "areacode":339, "number":4120211},
                       {"type":"work", "areacode":339, "number":8694021},
                       {"type":"home", "areacode":339, "number":1205678},
                       {"type":"home", "areacode":305, "number":8064321}
                      ]
            },
  "connections":[3, 5, 1, 2],
  "expenses":{"food":6000, "books":240, "clothes":2000, "shoes":1200}
};

{
  "id":5,
  "firstname":"Dana",
  "lastname":"Scully",
  "age":47
  "income":400000,
  "address":{"street":"427 Linden Avenue",
             "city":"Monroe Township",
             "state":"NJ",
             "phones":[{"type":"work", "areacode":201, "number":3213267},
                       {"type":"work", "areacode":201, "number":8765421},
                       {"type":"home", "areacode":339, "number":3414578}
                      ]
           },
  "connections":[2, 4, 1, 3],
  "expenses":{"food":900, "shoes":1000, "clothes":1500}
}; </pre>
      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
        <h3 class="title">Note</h3>
        <p>
            The Persons table models persons that may be connected to other persons
            in the same table. These connections are stored in the "connections"
            column, which is an array holding the ids of other persons that a
            person is connected with. It is assumed that the
            entries of each "connections" array are sorted (in descending order)
            by a measure of the strength of the connection. For example, person 3
            is most strongly connected with person 1, less strongly connected with
            person 4, and the least strongly connected with person 2.
          </p>
        <p>
            The Persons table includes an "expenses" column, which is a map of
            integers. It stores, for each person, the amount of money spent on
            various categories of items. Because the categories may be
            different for each person, and/or because we may want to add or delete
            categories dynamically (without changing the schema of the table), it
            makes sense to model this information in a map.
          </p>
      </div>
      <p> 
            To navigate inside complex values and select their nested values,
            SQL for Oracle NoSQL Database supports path expressions. Path expressions consist of a number
            of steps. There are 3 kinds of steps: field, filter, and slice
            steps. Field steps are used to select field/entry values from records or
            maps. Filter steps are used to select array or map entries that
            satisfy some condition. Slice steps are used to select array entries
            based on their position inside the containing array. A path
            expression can mix different kinds of steps. 
        </p>
      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
        <h3 class="title">Note</h3>
        <p>
                A path expression over a table row must always start with the
                table's name or the table's alias (if one was included in the
                FROM clause).
            </p>
      </div>
      <p> 
            In general, path expressions may return more than one item as
            their result. Such multi-item results can be used as input in two
            other kinds of expressions: sequence-comparison operators and array
            constructors.
        </p>
      <p>
            The following sections demonstrate examples of path expressions,
            sequence comparisons, and array constructors.
        </p>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="records"></a>Working With Records</h3>
            </div>
          </div>
        </div>
        <p> 
                You can use a field step to select the value of a field from
                a record. For example, to return the id, last name, and city of
                persons who reside in Florida:
            </p>
        <pre class="programlisting">onql-&gt; SELECT id, lastname, p.address.city 
FROM Persons p WHERE p.address.state = "FL";
 +----+----------+------------+
 | id | lastname |    city    |
 +----+----------+------------+
 |  3 | Morgan   | Middleburg |
 +----+----------+------------+

1 row returned </pre>
        <p>
                In the above query, the path expression
                    <code class="literal">p.address.state</code> consists of 2 field
                steps: <code class="literal">.address</code> selects the address field of
                the current row (rows can be viewed as records, whose fields are
                the row columns), and <code class="literal">.state</code> selects the
                state field of the current address.
            </p>
        <p> 
                The following example demonstrates sequence comparisons,
                which are done using the <code class="literal">any</code> operators: =any,
                &gt;any, &gt;=any, &lt;any, &lt;=any, and !=any. These should be used
                when one or both of the operands may be a sequence with more
                than one item. The <code class="literal">any</code> operators returns true
                if there is a pair of items, one from the left-hand-side and the
                other from the right-hand-side, that have the required
                relationship (equal, greater, etc). For example, to return the
                last name of persons who have a phone number with area code 423:
            </p>
        <pre class="programlisting">onql-&gt; SELECT lastname FROM Persons 
p WHERE p.address.phones.areacode =any 423;
 +----------+
 | lastname |
 +----------+
 | Morrison |
 +----------+

1 row returned </pre>
        <p> 
                In the above query, the path expression
                    <code class="literal">p.address.phones.areacode</code> returns all the
                area codes of a person. Then, the =any operator returns true if
                this sequence of area codes contains the number 423. Notice also
                that the field step <code class="literal">.areacode</code> is applied to
                an array field (phones). This is allowed if the array contains
                records or maps. In this case, the field step is applied to each
                element of the array in turn. 
            </p>
        <p> 
                SQL for Oracle NoSQL Database can also sort query results by the value of fields
                nested inside records, if again, an index on the nested field
                (or fields) exists. For example, to create an index and then order
                by state:
            </p>
        <pre class="programlisting">create index indx1 on Persons (address.state);
Statement completed successfully
onql-&gt; SELECT id, $p.address.state FROM 
Persons $p ORDER BY $p.address.state;
 +----+-------+
 | id | state |
 +----+-------+
 |  3 | FL    |
 |  4 | MA    |
 |  5 | NJ    |
 |  1 | TN    |
 |  2 | WI    |
 +----+-------+

5 rows returned </pre>
        <p>
        To learn more about indexes see <a class="xref" href="indexes.html" title="Working With Indexes">Working With Indexes</a>. 
        </p>
      </div>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="arrays"></a>Working With Arrays</h3>
            </div>
          </div>
        </div>
        <p>
            You can use slice or filter steps to select elements out of an array.
            We start with some examples using slice steps. 
          </p>
        <p> 
            To select and display the second connection of each person, we use the
            familiar array-indexing syntax:
          </p>
        <pre class="programlisting">onql-&gt; SELECT lastname, connections[1]
AS connection FROM Persons; 
 +----------+------------+
 | lastname | connection |
 +----------+------------+
 | Scully   |          2 |
 | Smith    |          4 |
 | Morgan   |          2 |
 | Anderson |          2 |
 | Morrison |          2 |
 +----------+------------+

5 rows returned </pre>
        <p> 
            In the above example, the slice step <code class="literal">[1]</code> is applied
            to the connections array. Array elements are numbered starting with 0, so 1
            is used to select the second connection. 
          </p>
        <p> 
            A slice step can also be used to select all array elements whose
            positions are within a range: [low:high], where low and high are expressions
            that compute the range boundaries. The low and/or the high expressions may
            be missing if no low and/or high boundary is desired.
          </p>
        <p> 
            For example, the following query returns the lastname and the first 3
            connections of person 5 as strongconnections:
          </p>
        <pre class="programlisting">onql-&gt; SELECT lastname, [connections[0:2]] 
AS strongconnections FROM Persons WHERE id = 5;
 +----------+-------------------+
 | lastname | strongconnections |
 +----------+-------------------+
 | Scully   | 2                 |
 |          | 4                 |
 |          | 1                 |
 +----------+-------------------+

1 row returned </pre>
        <p>
            In the above query, for Person 5, the path expression
              <code class="literal">connections[0:2]</code> returns the person's first 3
            connections. Here, the range is [0:2], so 0 is the low expression and 2 is
            the high expression. The path expression returns its result as a sequence of
            3 items. 
          </p>
        <p>
            The path expression appears inside the SELECT clause, which does not
            allow expressions that return more than one item. Therefore, the path expression
            should be enclosed in an array-constructor expression ([]), which creates a
            new array (single item) containing the 3 connections. Although the query
            shell displays the elements of this constructed array vertically, the number
            of rows returned by this query is 1.
          </p>
        <p> 
            As mentioned above, you can omit the low or high expression when
            specifying the range for a slice step. For example the following query
            specifies a range of [3:] which returns all connections after the third one.
            Notice that for persons having only 3 connections or less, an empty array is
            constructed and returned. 
          </p>
        <pre class="programlisting">onql-&gt; SELECT id, [connections[3:]] 
AS weakConnections FROM Persons;
+----+-----------------+
| id | weakConnections |
+----+-----------------+
|  4 | 2               |
+----+-----------------+
|  3 |                 |
+----+-----------------+
|  2 |                 |
+----+-----------------+
|  1 |                 |
+----+-----------------+
|  5 | 3               |
+----+-----------------+

5 rows returned </pre>
        <p>
            As a last example of slice steps, the following query returns the last
            3 connections of each person. In this query, the slice step is
              <code class="literal">[size($)-3:]</code>. In this expression, the $ is an
            implicitly declared variable that references the array that the slice step
            is applied to. In this example, $ references the connections array. The
            size() built-in function returns the size (number of elements) of the input
            array. So, in this example, size($) is the size of the current connections
            array. Finally, size($)-3 computes the third position from the end of the
            current connections array. 
          </p>
        <pre class="programlisting">onql-&gt; SELECT id, [connections[size($)-3:]] 
AS weakConnections FROM Persons;
 +----+-------------------+
 | id | weakConnections   |
 +----+-------------------+
 |  5 | 4                 |
 |    | 1                 |
 |    | 3                 |
 +----+-------------------+
 |  4 | 5                 |
 |    | 1                 |
 |    | 2                 |
 +----+-------------------+
 |  3 | 1                 |
 |    | 4                 |
 |    | 2                 |
 +----+-------------------+
 |  2 | 1                 |
 |    | 3                 |
 +----+-------------------+
 |  1 | 2                 |
 |    | 3                 |
 +----+-------------------+

5 rows returned </pre>
        <p> 
            We now turn our attention to filter steps on arrays. Like slice steps,
            filter steps use the square brackets ([]) syntax as well. However, what goes
            inside the [] is different. With filter steps there is either nothing inside
            the [] or a single expression that acts as a condition (returns a boolean
            result). In the former case, all the elements of the array are selected (the
            array is "unnested"). In the latter case, the condition is applied to each
            element in turn, and if the result is true, the element is selected,
            otherwise it is skipped. For example:
          </p>
        <p> 
            The following query returns the id and connections of persons who are
            connected to person 4:
          </p>
        <pre class="programlisting">onql-&gt; SELECT id, connections 
FROM Persons p WHERE p.connections[] =any 4;
 +----+-------------+
 | id | connections |
 +----+-------------+
 |  3 | 1           |
 |    | 4           |
 |    | 2           |
 +----+-------------+
 |  5 | 2           |
 |    | 4           |
 |    | 1           |
 |    | 3           |
 +----+-------------+

2 rows returned </pre>
        <p> 
            In the above query, the expression <code class="literal">p.connections[]</code>
            returns all the connections of a person. Then, the =any operator returns
            true if this sequence of connections contains the number 4. 
          </p>
        <p> 
            The following query returns the id and connections of persons who are
            connected with any person having an id greater than 4: 
          </p>
        <pre class="programlisting">onql-&gt; SELECT id, connections FROM Persons p 
WHERE p.connections[] &gt;any 4; 
 +----+-------------+
 | id | connections |
 +----+-------------+
 |  4 | 3           |
 |    | 5           |
 |    | 1           |
 |    | 2           |
 +----+-------------+

1 row returned </pre>
        <p>
            The following query returns, for each person, the person's last name
            and the phone numbers with area code 339:
          </p>
        <pre class="programlisting">onql-&gt; SELECT lastname, 
[ p.address.phones[$element.areacode = 339].number ] 
AS phoneNumbers FROM Persons p; 
 +----------+--------------+
 | lastname | phoneNumbers |
 +----------+--------------+
 | Scully   | 3414578      |
 +----------+--------------+
 | Smith    | 4120211      |
 |          | 8694021      |
 |          | 1205678      |
 +----------+--------------+
 | Morgan   |              |
 +----------+--------------+
 | Anderson | 1684972      |
 +----------+--------------+
 | Morrison |              |
 +----------+--------------+

5 rows returned </pre>
        <p> 
            In the above query, the filter step <code class="literal">[$element.areacode =
              339]</code> is applied to the phones array of each person. The filter
            step evaluates the condition <code class="literal">$element.areacode = 339</code> on
            each element of the array. This condition expression uses the implicitly
            declared variable $element, which references the current element of the
            array. Because the whole path expression may return more than one phone
            number, it is enclosed in an array constructor to collect the selected phone
            numbers into a single array. An empty array is returned for persons that do
            not have any phone number in the 339 area code. If we wanted to filter out
            such persons from the result, we would write the following query: 
          </p>
        <pre class="programlisting">onql-&gt; SELECT lastname, 
[ p.address.phones[$element.areacode = 339].number ] 
AS phoneNumbers FROM Persons p WHERE p.address.phones.areacode =any 339
 +----------+--------------+
 | lastname | phoneNumbers |
 +----------+--------------+
 | Scully   | 3414578      |
 +----------+--------------+
 | Smith    | 4120211      |
 |          | 8694021      |
 |          | 1205678      |
 +----------+--------------+
 | Anderson | 1684972      |
 +----------+--------------+

3 rows returned </pre>
        <p> 
            In addition to the implicitly-declared $ and $element variables, the
            condition inside a filter step can also use the $elementPos variable (also
            implicitly declared). $elementPos references the position within the array
            of the current element (the element on which the condition is applied). For
            example, the following query selects the "interesting" connections of each
            person, where a connection is considered interesting if it is among the 3
            strongest connections and connects to a person with an id greater or equal
            to 4.
          </p>
        <pre class="programlisting">onql-&gt; SELECT id, [p.connections[$element &gt;= 4 and $elementPos &lt; 3]] 
AS interestingConnections FROM Persons p; 
 +----+------------------------+
 | id | interestingConnections |
 +----+------------------------+
 |  5 | 4                      |
 +----+------------------------+
 |  4 | 5                      |
 +----+------------------------+
 |  3 | 4                      |
 +----+------------------------+
 |  2 |                        |
 +----+------------------------+
 |  1 |                        |
 +----+------------------------+

5 rows returned </pre>
        <p>
            Finally, two arrays can be compared with each other using the usual
            comparison operators (=, !=, &gt;, &gt;=, &gt;, and &gt;=). For example the
            following query constructs the array [1,3] and selects persons whose
            connections array is equal to [1,3]. 
          </p>
        <pre class="programlisting">onql-&gt; SELECT lastname FROM Persons p
WHERE p.connections = [1,3];
 +----------+
 | lastname |
 +----------+
 | Anderson |
 +----------+

1 row returned </pre>
      </div>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="maps"></a>Working With Maps</h3>
            </div>
          </div>
        </div>
        <p>
                The path steps applicable to maps are field and filter steps.
                Slice steps do not make sense for maps, because maps are unordered,
                and as a result, their entries do not have any fixed positions.
            </p>
        <p>
                You can use a field step to select the value of a field from
                a map. For example, to return the lastname and the food
                expenses of all persons:
            </p>
        <pre class="programlisting">onql-&gt; SELECT lastname, p.expenses.food 
FROM Persons p;
 +----------+------+
 | lastname | food |
 +----------+------+
 | Morgan   | 2000 |
 | Morrison | 1000 |
 | Scully   |  900 |
 | Smith    | 6000 |
 | Anderson | 1700 |
 +----------+------+

5 rows returned </pre>
        <p> 
                In the above query, the path expression
                <code class="literal">p.expenses.food</code> consists of 2 field
                steps: <code class="literal">.expenses</code> selects the expenses
                field of the current row and <code class="literal">.food</code> selects
                the value of the food field/entry from the current expenses map.
            </p>
        <p> 
                To return the lastname and amount spent on travel for each person
                who spent less than $3000 on food: 
            </p>
        <pre class="programlisting">onql-&gt; SELECT lastname, p.expenses.travel
FROM Persons p WHERE p.expenses.food &lt; 3000;
 +----------+--------+
 | lastname | travel |
 +----------+--------+
 | Scully   |   NULL |
 | Morgan   |    700 |
 | Anderson |   2100 |
 | Morrison |   NULL |
 +----------+--------+

4 rows returned </pre>
        <p>
              Notice that NULL is returned for persons who did not have any
              travel expenses.
            </p>
        <p> 
                Filter steps on maps work the same way as in arrays. Empty square
                brackets return all the values in a map. If the square brackets
                contain a condition expression the condition is evaluated for
                each entry, and the entry is selected/skipped if the result is true/false.
                The implicitly-declared variables $key and $element can be used
                inside a map filter condition. $key references the key of the
                current entry and $element references the associated value.
                Notice that, contrary to arrays, the $elementPos variable can not be
                be used inside map filters (because map entries do not have
                fixed positions).
            </p>
        <p> 
                To return the id and expenses data of any person who
                spent more on any category than what they spent on food:
            </p>
        <pre class="programlisting">onql-&gt; SELECT id, p.expenses 
FROM Persons p
WHERE p.expenses[] &gt;any p.expenses.food;
 +----+---------------------+
 | id |      expenses       |
 +----+---------------------+
 |  5 | clothes  | 1500     |
 |    | food     | 900      |
 |    | shoes    | 1000     |
 +----+---------------------+
 |  2 | books    | 100      |
 |    | food     | 1700     |
 |    | travel   | 2100     |
 +----+---------------------+

2 rows returned </pre>
        <p> 
               To return the id of all persons who consumed more than $2000 in
               any category other than food:
            </p>
        <pre class="programlisting">onql-&gt; SELECT id FROM Persons p
WHERE p.expenses[$key != "food"] &gt;any 2000;
 +----+
 | id |
 +----+
 |  2 |
 +----+

1 row returned </pre>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="simple_expressions.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="sfw_expression.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="functions.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Simple Select-From-Where
            Queries </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Home</a>
          </td>
          <td width="40%" align="right" valign="top"> Built-in Functions</td>
        </tr>
      </table>
    </div>
  </body>
</html>
